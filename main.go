package main

import (
	"flag"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const fileTemplate = `//go:build !ignore_autogenerated 
// +build !ignore_autogenerated

// This file was generated by gen-errfuncs.  DO NOT EDIT.

package {{.Package}}

import (
	"errors"
	"fmt"
)
{{ range .Errors }} 
func {{ .Radix }}(err error) error {
	return errors.Join({{ .Name }}, err)
}

func {{ .Radix }}f(msg string, args ...any) error {
	return fmt.Errorf("%w: %s", {{ .Name }}, fmt.Sprintf(msg, args...))
}
{{ end -}}

`

var (
	targetFile = "zzz_errfuncs.go"
)

func init() {
	flag.StringVar(&targetFile, "out", targetFile, "where to write the output")
	flag.Parse()
}

func main() {

	sourcePath := flag.Arg(0)
	if sourcePath == "" {
		log.Fatal("missing source file")
	}
	spec := parseFile(sourcePath)
	targetPath := filepath.Join(filepath.Dir(sourcePath), targetFile)
	render(targetPath, spec)
}

type fileSpec struct {
	Package string
	Errors  []errSpec
}
type errSpec struct {
	Name  string
	Radix string
}

func parseFile(path string) *fileSpec {
	data, err := os.ReadFile(path)
	if err != nil {
		log.Fatal(err)
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "demo", data, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	spec := &fileSpec{
		Package: file.Name.Name,
		Errors:  make([]errSpec, 0, 10),
	}
	for name := range file.Scope.Objects {
		if radix, ok := strings.CutPrefix(name, "Err"); ok {
			spec.Errors = append(spec.Errors, errSpec{name, radix})
		}
	}
	return spec
}

func render(path string, spec *fileSpec) {
	tmpl := template.Must(template.New(path).Parse(fileTemplate))
	out, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		log.Fatalf("couldn't open %s: %s", path, err)
	}
	tmpl.Execute(out, spec)
}
